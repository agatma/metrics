
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">metrics/cmd/agent/main.go (0.0%)</option>
				
				<option value="file1">metrics/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">metrics/internal/agent/adapters/storage/memory/storage.go (0.0%)</option>
				
				<option value="file3">metrics/internal/agent/adapters/storage/storage.go (0.0%)</option>
				
				<option value="file4">metrics/internal/agent/adapters/workers/worker.go (0.0%)</option>
				
				<option value="file5">metrics/internal/agent/config/config.go (0.0%)</option>
				
				<option value="file6">metrics/internal/agent/core/handlers/handlers.go (0.0%)</option>
				
				<option value="file7">metrics/internal/agent/core/service/service.go (0.0%)</option>
				
				<option value="file8">metrics/internal/agent/logger/logger.go (0.0%)</option>
				
				<option value="file9">metrics/internal/server/adapters/api/rest/helpers.go (28.6%)</option>
				
				<option value="file10">metrics/internal/server/adapters/api/rest/middleware.go (0.0%)</option>
				
				<option value="file11">metrics/internal/server/adapters/api/rest/rest.go (6.4%)</option>
				
				<option value="file12">metrics/internal/server/adapters/storage/database/migrate.go (0.0%)</option>
				
				<option value="file13">metrics/internal/server/adapters/storage/database/postgres.go (0.0%)</option>
				
				<option value="file14">metrics/internal/server/adapters/storage/file/storage.go (0.0%)</option>
				
				<option value="file15">metrics/internal/server/adapters/storage/memory/storage.go (93.5%)</option>
				
				<option value="file16">metrics/internal/server/adapters/storage/storage.go (31.2%)</option>
				
				<option value="file17">metrics/internal/server/config/config.go (0.0%)</option>
				
				<option value="file18">metrics/internal/server/core/files/file.go (58.1%)</option>
				
				<option value="file19">metrics/internal/server/core/service/mocks/mock.go (0.0%)</option>
				
				<option value="file20">metrics/internal/server/core/service/service.go (53.9%)</option>
				
				<option value="file21">metrics/internal/server/logger/logger.go (0.0%)</option>
				
				<option value="file22">metrics/internal/shared-kernel/compress/gzip.go (0.0%)</option>
				
				<option value="file23">metrics/internal/shared-kernel/hash/hash.go (0.0%)</option>
				
				<option value="file24">metrics/internal/shared-kernel/retrying/retry.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"

        "metrics/internal/agent/adapters/storage"
        "metrics/internal/agent/adapters/storage/memory"
        "metrics/internal/agent/adapters/workers"
        "metrics/internal/agent/config"
        "metrics/internal/agent/core/service"
        "metrics/internal/agent/logger"
)

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func run() error <span class="cov0" title="0">{
        cfg, err := config.NewConfig()
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't load config: %w", err)
        }</span>
        <span class="cov0" title="0">if err = logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't load logger: %w", err)
        }</span>
        <span class="cov0" title="0">gaugeAgentStorage, err := storage.NewAgentStorage(storage.Config{
                Memory: &amp;memory.Config{},
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize a storage: %w", err)
        }</span>
        <span class="cov0" title="0">counterAgentStorage, err := storage.NewAgentStorage(storage.Config{
                Memory: &amp;memory.Config{},
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize a storage: %w", err)
        }</span>
        <span class="cov0" title="0">agentMetricService := service.NewAgentMetricService(gaugeAgentStorage, counterAgentStorage)
        worker := workers.NewAgentWorker(agentMetricService, cfg)
        if err = worker.Run(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server has failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "fmt"
        "log"
        "metrics/internal/server/adapters/storage/database"
        "net/http"
        "time"

        "metrics/internal/server/adapters/api/rest"
        "metrics/internal/server/adapters/storage"
        "metrics/internal/server/adapters/storage/file"
        "metrics/internal/server/adapters/storage/memory"
        "metrics/internal/server/config"
        "metrics/internal/server/core/service"
        "metrics/internal/server/logger"

        "go.uber.org/zap"
)

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func run() error <span class="cov0" title="0">{
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't load config: %w", err)
        }</span>
        <span class="cov0" title="0">if err = logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't load logger: %w", err)
        }</span>
        <span class="cov0" title="0">metricStorage, err := initMetricStorage(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize a storage: %w", err)
        }</span>
        <span class="cov0" title="0">metricService, err := service.NewMetricService(cfg.FileStoragePath, metricStorage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize a service: %w", err)
        }</span>
        <span class="cov0" title="0">if cfg.Restore </span><span class="cov0" title="0">{
                err = metricService.LoadMetrics()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to restore data for metric service %w", err)
                }</span>
        }
        <span class="cov0" title="0">if cfg.StoreInterval &gt; 0 </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        t := time.NewTicker(time.Duration(cfg.StoreInterval) * time.Second)
                        for </span><span class="cov0" title="0">{
                                &lt;-t.C
                                err = metricService.SaveMetrics()
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("failed to save metrics", zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">logger.Log.Info("metrics saved to file after timeout", zap.Int("seconds", cfg.StoreInterval))</span>
                        }
                }()
        }
        <span class="cov0" title="0">api := rest.NewAPI(metricService, cfg)
        if err = api.Run(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        err = metricService.SaveMetrics()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to save metrics during shutdown: %w", err)
                        }</span>
                        <span class="cov0" title="0">logger.Log.Info("metrics are saved to file")
                        return nil</span>
                }

                <span class="cov0" title="0">return fmt.Errorf("server has failed: %w", err)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func initMetricStorage(cfg *config.Config) (storage.MetricStorage, error) <span class="cov0" title="0">{
        switch </span>{
        case cfg.DatabaseDSN != "":<span class="cov0" title="0">
                metricStorage, err := storage.NewStorage(storage.Config{
                        Database: &amp;database.Config{
                                DSN: cfg.DatabaseDSN,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to init db storage %w", err)
                }</span>
                <span class="cov0" title="0">logger.Log.Info("initialize db storage")
                return metricStorage, nil</span>
        case cfg.FileStoragePath == "":<span class="cov0" title="0">
                metricStorage, err := storage.NewStorage(storage.Config{
                        Memory: &amp;memory.Config{},
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to init memory storage %w", err)
                }</span>
                <span class="cov0" title="0">logger.Log.Info("initialize memory storage")
                return metricStorage, nil</span>
        default:<span class="cov0" title="0">
                metricStorage, err := storage.NewStorage(storage.Config{
                        File: &amp;file.Config{
                                Filepath:      cfg.FileStoragePath,
                                StoreInterval: cfg.StoreInterval,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to init file storage %w", err)
                }</span>
                <span class="cov0" title="0">logger.Log.Info("initialize file storage")
                return metricStorage, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package memory

import (
        "sync"

        "metrics/internal/agent/core/domain"
)

type AgentMetricStorage struct {
        mux  *sync.Mutex
        data map[string]string
}

func NewAgentStorage(cfg *Config) *AgentMetricStorage <span class="cov0" title="0">{
        return &amp;AgentMetricStorage{
                mux:  &amp;sync.Mutex{},
                data: make(map[string]string),
        }
}</span>

func (s *AgentMetricStorage) GetAllMetrics(req *domain.GetAllMetricsRequest) *domain.GetAllMetricsResponse <span class="cov0" title="0">{
        s.mux.Lock()
        defer s.mux.Unlock()
        return &amp;domain.GetAllMetricsResponse{
                Values: s.data,
        }
}</span>

func (s *AgentMetricStorage) GetMetricValue(req *domain.MetricRequest) *domain.MetricResponse <span class="cov0" title="0">{
        s.mux.Lock()
        defer s.mux.Unlock()
        value, found := s.data[req.MetricName]
        return &amp;domain.MetricResponse{
                MetricValue: value,
                Found:       found,
        }
}</span>

func (s *AgentMetricStorage) SetMetricValue(req *domain.SetMetricRequest) *domain.SetMetricResponse <span class="cov0" title="0">{
        s.mux.Lock()
        defer s.mux.Unlock()
        s.data[req.MetricName] = req.MetricValue
        return &amp;domain.SetMetricResponse{
                Error: nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package storage provides implementations of the AgentMetricStorage interface.
//
// This package offers a memory-based storage adapter for metrics.
package storage

import (
        "errors"

        "metrics/internal/agent/adapters/storage/memory"
        "metrics/internal/agent/core/domain"
)

// AgentMetricStorage defines the interface for metric storage operations.
type AgentMetricStorage interface {
        // GetMetricValue retrieves the value of a specific metric based on the provided request.
        GetMetricValue(request *domain.MetricRequest) *domain.MetricResponse

        // SetMetricValue sets the value of a specific metric based on the provided request.
        SetMetricValue(request *domain.SetMetricRequest) *domain.SetMetricResponse

        // GetAllMetrics retrieves all metrics based on the provided request.
        GetAllMetrics(request *domain.GetAllMetricsRequest) *domain.GetAllMetricsResponse
}

// NewAgentStorage creates a new AgentMetricStorage instance based on the provided configuration.
//
// If memory storage is enabled in the configuration, it returns a memory-based storage adapter.
// Otherwise, it returns an error indicating that no available agent storage was provided.
func NewAgentStorage(conf Config) (AgentMetricStorage, error) <span class="cov0" title="0">{
        if conf.Memory != nil </span><span class="cov0" title="0">{
                return memory.NewAgentStorage(conf.Memory), nil
        }</span>
        <span class="cov0" title="0">return nil, errors.New("no available agent storage")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package workers provides functionality for collecting, reporting, and sending metrics.
//
// It defines an AgentWorker struct that handles metric collection, reporting, and sending.
// The package uses goroutines and channels to manage concurrent operations.
package workers

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"
        "golang.org/x/sync/errgroup"

        "metrics/internal/agent/config"
        "metrics/internal/agent/core/domain"
        "metrics/internal/agent/logger"
)

// Metrics represents the number of metrics collected per poll interval.
const metrics = 100

// AgentMetricService defines the interface for metric-related operations.
type AgentMetricService interface {
        // CollectMetrics collects metrics based on the given poll count.
        CollectMetrics(pollCount int) error

        // ReportMetrics reports collected metrics to the channel.
        ReportMetrics(jobs chan&lt;- domain.MetricRequestJSON) error

        // SendMetrics sends reported metrics asynchronously.
        SendMetrics(ctx context.Context, cfg *config.Config, jobs &lt;-chan domain.MetricRequestJSON) error
}

// AgentWorker manages the collection, reporting, and sending of metrics.
type AgentWorker struct {
        agentMetricService AgentMetricService
        config             *config.Config
}

// NewAgentWorker creates a new AgentWorker instance.
func NewAgentWorker(agentMetricService AgentMetricService, cfg *config.Config) *AgentWorker <span class="cov0" title="0">{
        return &amp;AgentWorker{
                agentMetricService: agentMetricService,
                config:             cfg,
        }
}</span>

// collectMetrics runs in a separate goroutine to continuously collect metrics.
func (a *AgentWorker) collectMetrics(ctx context.Context) error <span class="cov0" title="0">{
        collectMetricsTicker := time.NewTicker(time.Duration(a.config.PollInterval) * time.Second)
        defer collectMetricsTicker.Stop()

        pollCount := 0
        for range collectMetricsTicker.C </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0">
                        err := a.agentMetricService.CollectMetrics(pollCount)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("error occurred during collecting metrics", zap.Error(err))
                                return fmt.Errorf("error occurred during collecting metrics %w", err)
                        }</span>
                        <span class="cov0" title="0">pollCount++</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// reportMetrics runs in a separate goroutine to continuously report collected metrics.
func (a *AgentWorker) reportMetrics(ctx context.Context, jobs chan&lt;- domain.MetricRequestJSON) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        reportMetricsTicker := time.NewTicker(time.Duration(a.config.ReportInterval) * time.Second)
        defer reportMetricsTicker.Stop()

        pollCount := 0
        for range reportMetricsTicker.C </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0">
                        err := a.agentMetricService.ReportMetrics(jobs)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("error occurred during reporting metrics", zap.Error(err))
                                return fmt.Errorf("%w", err)
                        }</span>
                        <span class="cov0" title="0">pollCount++</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Run starts the worker and manages its lifecycle.
func (a *AgentWorker) Run(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        jobs := make(chan domain.MetricRequestJSON, metrics)

        go func() </span><span class="cov0" title="0">{
                if err := a.collectMetrics(ctx); err != nil </span><span class="cov0" title="0">{
                        cancel()
                }</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := a.reportMetrics(ctx, jobs); err != nil </span><span class="cov0" title="0">{
                        cancel()
                }</span>
        }()

        <span class="cov0" title="0">g := new(errgroup.Group)
        for w := 1; w &lt;= a.config.RateLimit; w++ </span><span class="cov0" title="0">{
                g.Go(func() error </span><span class="cov0" title="0">{
                        err := a.agentMetricService.SendMetrics(ctx, a.config, jobs)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
        }
        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error occurred during sending metrics", zap.Error(err))
                return fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "flag"
        "fmt"
        "strings"

        "github.com/caarlos0/env/v11"
)

const (
        defaultPollInterval   = 2
        defaultReportInterval = 10
)

type Config struct {
        Address        string `env:"ADDRESS"`
        ReportInterval int    `env:"REPORT_INTERVAL"`
        PollInterval   int    `env:"POLL_INTERVAL"`
        RateLimit      int    `env:"RATE_LIMIT"`
        Key            string `env:"KEY"`
        LogLevel       string
        Host           string
}

func NewConfig() (*Config, error) <span class="cov0" title="0">{
        var cfg Config
        flag.StringVar(&amp;cfg.Address, "a", "localhost:8080", "run address")
        flag.IntVar(&amp;cfg.PollInterval, "p", defaultPollInterval, " poll interval ")
        flag.IntVar(&amp;cfg.ReportInterval, "r", defaultReportInterval, " report interval ")
        flag.StringVar(&amp;cfg.LogLevel, "L", "info", "log level")
        flag.IntVar(&amp;cfg.RateLimit, "l", 1, "rate limit")
        flag.StringVar(&amp;cfg.Key, "k", "", "hashing key")
        flag.Parse()
        err := env.Parse(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, fmt.Errorf("failed to get config for worker: %w", err)
        }</span>
        <span class="cov0" title="0">address := strings.Split(cfg.Address, ":")
        port := "8080"
        if len(address) &gt; 1 </span><span class="cov0" title="0">{
                port = address[1]
        }</span>
        <span class="cov0" title="0">cfg.Host = "http://localhost:" + port
        return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package handlers provides functionality for sending metrics.
package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/go-resty/resty/v2"
        "go.uber.org/zap"

        "metrics/internal/agent/config"
        "metrics/internal/agent/core/domain"
        "metrics/internal/agent/logger"
        "metrics/internal/shared-kernel/compress"
        "metrics/internal/shared-kernel/hash"
)

// SendMetrics sends metrics to the configured endpoint.
//
// This function marshals the provided MetricRequestJSON, compresses the data,
// and sends it to the specified host using RESTy.
//
// Args:
//
//        cfg *config.Config: Configuration object containing host and key information.
//        request *domain.MetricRequestJSON: Request containing metric data.
//
// Returns:
//
//        error: Any error that occurs during the process.
//
// Side effects:
//   - Sends HTTP POST request to the configured endpoint.
//   - Logs the request details if successful.
func SendMetrics(cfg *config.Config, request *domain.MetricRequestJSON) error <span class="cov0" title="0">{
        data, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse model: %w", err)
        }</span>
        <span class="cov0" title="0">buf, err := compress.GzipData(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to gzip metrics: %w", err)
        }</span>
        <span class="cov0" title="0">client := resty.New()
        req := client.R().
                SetHeader("Content-Type", `application/json`).
                SetHeader("Content-Encoding", `gzip`).
                SetHeader("Accept-Encoding", `gzip`)
        if cfg.Key != "" </span><span class="cov0" title="0">{
                req.SetHeader(hash.Header, hash.Encode(buf, cfg.Key))
        }</span>
        <span class="cov0" title="0">resp, err := req.SetBody(buf).Post(cfg.Host + "/update/")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send metrics: %w", err)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("bad request. Status Code %d", resp.StatusCode())
        }</span>
        <span class="cov0" title="0">logger.Log.Info(
                "made http request",
                zap.String("uri", resp.Request.URL),
                zap.String("method", resp.Request.Method),
                zap.Int("statusCode", resp.StatusCode()),
                zap.Duration("duration", resp.Time()),
        )
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package service provides functionality for collecting and reporting metrics.
package service

import (
        "context"
        "errors"
        "fmt"
        "math/rand"
        "runtime"
        "strconv"
        "time"

        "github.com/avast/retry-go"
        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
        "go.uber.org/zap"

        "metrics/internal/agent/config"
        "metrics/internal/agent/core/domain"
        "metrics/internal/agent/core/handlers"
        "metrics/internal/agent/logger"
        "metrics/internal/shared-kernel/retrying"
)

// AgentMetricStorage defines the interface for storing and retrieving metrics.
type AgentMetricStorage interface {
        // GetMetricValue retrieves a single metric value.
        GetMetricValue(request *domain.MetricRequest) *domain.MetricResponse

        // SetMetricValue stores a single metric value.
        SetMetricValue(request *domain.SetMetricRequest) *domain.SetMetricResponse

        // GetAllMetrics retrieves all metrics.
        GetAllMetrics(request *domain.GetAllMetricsRequest) *domain.GetAllMetricsResponse
}

// AgentMetricService manages the collection and storage of metrics.
type AgentMetricService struct {
        gaugeAgentStorage   AgentMetricStorage
        counterAgentStorage AgentMetricStorage
}

// NewAgentMetricService creates a new instance of AgentMetricService.
func NewAgentMetricService(
        gaugeAgentStorage AgentMetricStorage,
        counterAgentStorage AgentMetricStorage,
) *AgentMetricService <span class="cov0" title="0">{
        return &amp;AgentMetricService{
                gaugeAgentStorage:   gaugeAgentStorage,
                counterAgentStorage: counterAgentStorage,
        }
}</span>

// collectMemStats collects memory statistics and returns them as a Metrics object.
func (a *AgentMetricService) collectMemStats() domain.Metrics <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        vm, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to get vm metric", zap.Error(err))
        }</span>
        <span class="cov0" title="0">cpuMetric, err := cpu.Percent(time.Millisecond, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to get cpu metric", zap.Error(err))
        }</span>
        <span class="cov0" title="0">metrics := map[string]string{
                "Alloc":           strconv.FormatUint(m.Alloc, 10),
                "BuckHashSys":     strconv.FormatUint(m.BuckHashSys, 10),
                "CPUutilization1": strconv.FormatFloat(cpuMetric[0], 'f', 6, 64),
                "Frees":           strconv.FormatUint(m.Frees, 10),
                "FreeMemory":      strconv.FormatFloat(float64(vm.Free), 'f', 6, 64),
                "GCCPUFraction":   strconv.FormatFloat(m.GCCPUFraction, 'f', 6, 64),
                "GCSys":           strconv.FormatUint(m.GCSys, 10),
                "HeapAlloc":       strconv.FormatUint(m.HeapAlloc, 10),
                "HeapIdle":        strconv.FormatUint(m.HeapIdle, 10),
                "HeapInuse":       strconv.FormatUint(m.HeapInuse, 10),
                "HeapObjects":     strconv.FormatUint(m.HeapObjects, 10),
                "HeapReleased":    strconv.FormatUint(m.HeapReleased, 10),
                "HeapSys":         strconv.FormatUint(m.HeapSys, 10),
                "LastGC":          strconv.FormatUint(m.LastGC, 10),
                "Lookups":         strconv.FormatUint(m.Lookups, 10),
                "MCacheInuse":     strconv.FormatUint(m.MCacheInuse, 10),
                "MCacheSys":       strconv.FormatUint(m.MCacheSys, 10),
                "MSpanInuse":      strconv.FormatUint(m.MSpanInuse, 10),
                "MSpanSys":        strconv.FormatUint(m.MSpanSys, 10),
                "Mallocs":         strconv.FormatUint(m.Mallocs, 10),
                "NextGC":          strconv.FormatUint(m.NextGC, 10),
                "NumForcedGC":     strconv.FormatUint(uint64(m.NumForcedGC), 10),
                "NumGC":           strconv.FormatUint(uint64(m.NumGC), 10),
                "OtherSys":        strconv.FormatUint(m.OtherSys, 10),
                "PauseTotalNs":    strconv.FormatUint(m.PauseTotalNs, 10),
                "StackInuse":      strconv.FormatUint(m.StackInuse, 10),
                "StackSys":        strconv.FormatUint(m.StackSys, 10),
                "Sys":             strconv.FormatUint(m.Sys, 10),
                "TotalAlloc":      strconv.FormatUint(m.TotalAlloc, 10),
                "TotalMemory":     strconv.FormatFloat(float64(vm.Total), 'f', 6, 64),
        }
        return domain.Metrics{
                Values: metrics,
        }</span>
}

// CollectMetrics collects various system metrics and stores them using the gauge agent storage.
func (a *AgentMetricService) CollectMetrics(pollCount int) error <span class="cov0" title="0">{
        metrics := a.collectMemStats()
        for metricName, metricValue := range metrics.Values </span><span class="cov0" title="0">{
                response := a.gaugeAgentStorage.SetMetricValue(&amp;domain.SetMetricRequest{
                        MetricType:  domain.Gauge,
                        MetricName:  metricName,
                        MetricValue: metricValue,
                })
                if response.Error != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("failed to update gauge metric", zap.Error(response.Error))
                        return fmt.Errorf("failed to update gauge metric: %w", response.Error)
                }</span>
        }

        <span class="cov0" title="0">response := a.gaugeAgentStorage.SetMetricValue(&amp;domain.SetMetricRequest{
                MetricType:  domain.Gauge,
                MetricName:  domain.RandomValue,
                MetricValue: strconv.FormatFloat(rand.Float64(), 'f', 6, 64),
        })
        if response.Error != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to update random value", zap.Error(response.Error))
                return fmt.Errorf("failed to update random value: %w", response.Error)
        }</span>

        <span class="cov0" title="0">response = a.counterAgentStorage.SetMetricValue(&amp;domain.SetMetricRequest{
                MetricType:  domain.Counter,
                MetricName:  domain.PollCount,
                MetricValue: strconv.Itoa(pollCount),
        })
        if response.Error != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to update pollCount", zap.Error(response.Error))
                return fmt.Errorf("failed to update pollCount: %w", response.Error)
        }</span>

        <span class="cov0" title="0">logger.Log.Info("metrics collected")
        return nil</span>
}

// getAllMetrics retrieves metrics based on the given metric type.
func (a *AgentMetricService) getAllMetrics(request *domain.GetAllMetricsRequest) *domain.GetAllMetricsResponse <span class="cov0" title="0">{
        switch request.MetricType </span>{
        case domain.Gauge:<span class="cov0" title="0">
                return a.gaugeAgentStorage.GetAllMetrics(request)</span>
        case domain.Counter:<span class="cov0" title="0">
                return a.counterAgentStorage.GetAllMetrics(request)</span>
        default:<span class="cov0" title="0">
                return &amp;domain.GetAllMetricsResponse{
                        Error: errors.New("metric type is not found"),
                }</span>
        }
}

// ReportMetrics sends collected metrics to the configured destination.
func (a *AgentMetricService) ReportMetrics(jobs chan&lt;- domain.MetricRequestJSON) error <span class="cov0" title="0">{
        response := a.getAllMetrics(&amp;domain.GetAllMetricsRequest{
                MetricType: domain.Gauge,
        })
        if response.Error != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error occurred during getting gauge metrics", zap.Error(response.Error))
                return fmt.Errorf("error occurred during getting gauge metrics: %w", response.Error)
        }</span>

        <span class="cov0" title="0">for metricName, metricValue := range response.Values </span><span class="cov0" title="0">{
                gaugeValue, err := strconv.ParseFloat(metricValue, 64)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error occurred during parsing gauge metrics", zap.Error(err))
                        return fmt.Errorf("error occurred during parsing gauge metrics: %w", err)
                }</span>
                <span class="cov0" title="0">request := domain.MetricRequestJSON{
                        ID:    metricName,
                        MType: domain.Gauge,
                        Value: &amp;gaugeValue,
                }
                jobs &lt;- request</span>
        }

        <span class="cov0" title="0">response = a.getAllMetrics(&amp;domain.GetAllMetricsRequest{
                MetricType: domain.Counter,
        })
        if response.Error != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error occurred during getting counter metrics", zap.Error(response.Error))
                return fmt.Errorf("error occurred during getting counter metrics: %w", response.Error)
        }</span>

        <span class="cov0" title="0">for metricName, metricValue := range response.Values </span><span class="cov0" title="0">{
                counterValue, err := strconv.Atoi(metricValue)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error occurred during parsing counter metrics", zap.Error(err))
                        return fmt.Errorf("error occurred during parsing counter metrics: %w", err)
                }</span>
                <span class="cov0" title="0">counterInt64Value := int64(counterValue)
                request := domain.MetricRequestJSON{
                        ID:    metricName,
                        MType: domain.Counter,
                        Delta: &amp;counterInt64Value,
                }
                jobs &lt;- request</span>
        }

        <span class="cov0" title="0">logger.Log.Info("metrics reported")
        return nil</span>
}

// SendMetrics sends metrics asynchronously using the retry-go package.
func (a *AgentMetricService) SendMetrics(
        ctx context.Context,
        cfg *config.Config,
        jobs &lt;-chan domain.MetricRequestJSON,
) error <span class="cov0" title="0">{
        var err error
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case req, ok := &lt;-jobs:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">err = retry.Do(
                                func() error </span><span class="cov0" title="0">{
                                        err = handlers.SendMetrics(cfg, &amp;req)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Error("error occurred during sending metrics", zap.Error(err))
                                                return fmt.Errorf("failed to send metrics: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                },
                                retry.Attempts(retrying.Attempts),
                                retry.DelayType(retrying.DelayType),
                                retry.OnRetry(retrying.OnRetry),
                        )
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("error occurred during sending metrics", zap.Error(err))
                                return fmt.Errorf("failed to send metrics: %w", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "fmt"

        "go.uber.org/zap"
)

var Log *zap.Logger = zap.NewNop()

// Initialize инициализирует синглтон логера с необходимым уровнем логирования.
func Initialize(level string) error <span class="cov0" title="0">{
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse log level: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := zap.NewProductionConfig()
        cfg.Level = lvl
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build log config: %w", err)
        }</span>
        <span class="cov0" title="0">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rest

import (
        "errors"
        "metrics/internal/server/core/domain"
        "net/http"
)

func handleSetMetricError(w http.ResponseWriter, err error) <span class="cov8" title="1">{
        switch </span>{
        case errors.Is(err, domain.ErrItemNotFound):<span class="cov0" title="0">
                http.Error(w, err.Error(), http.StatusNotFound)</span>
        case errors.Is(err, domain.ErrIncorrectMetricType) || errors.Is(err, domain.ErrIncorrectMetricValue):<span class="cov8" title="1">
                http.Error(w, err.Error(), http.StatusBadRequest)</span>
        default:<span class="cov0" title="0">
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)</span>
        }
}

func handleGetMetricError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        if errors.Is(err, domain.ErrIncorrectMetricType) || errors.Is(err, domain.ErrItemNotFound) </span><span class="cov0" title="0">{
                http.Error(w, domain.ErrItemNotFound.Error(), http.StatusNotFound)
        }</span> else<span class="cov0" title="0"> {
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rest

import (
        "bytes"
        "compress/gzip"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "go.uber.org/zap"

        "metrics/internal/server/logger"
        "metrics/internal/shared-kernel/compress"
        "metrics/internal/shared-kernel/hash"
)

// responseData holds status and size information for responses.
type responseData struct {
        status int
        size   int
}

// loggingResponseWriter wraps an http.ResponseWriter to track response data.
type loggingResponseWriter struct {
        http.ResponseWriter
        responseData *responseData
}

// Write implements http.ResponseWriter.Write.
func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := r.ResponseWriter.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return size, fmt.Errorf("failed to write response %w", err)
        }</span>
        <span class="cov0" title="0">r.responseData.size += size
        return size, nil</span>
}

// WriteHeader implements http.ResponseWriter.WriteHeader.
func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode
}</span>

// LoggingRequestMiddleware logs incoming HTTP requests.
func (h *Handler) LoggingRequestMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        logFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                respData := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w,
                        responseData:   respData,
                }
                next.ServeHTTP(&amp;lw, r)
                duration := time.Since(start)
                if respData.status == 0 </span><span class="cov0" title="0">{
                        respData.status = 200
                }</span>
                <span class="cov0" title="0">logger.Log.Info("got incoming http request",
                        zap.String("method", r.Method),
                        zap.String("uri", r.RequestURI),
                        zap.Int("status", respData.status),
                        zap.Int("size", respData.size),
                        zap.String("duration", duration.String()),
                )</span>
        }
        <span class="cov0" title="0">return http.HandlerFunc(logFn)</span>
}

// CompressRequestMiddleware compresses incoming HTTP requests.
func (h *Handler) CompressRequestMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !strings.Contains(r.Header.Get("Content-Encoding"), "gzip") </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov0" title="0">gzBody := r.Body
                defer func(gzipBody io.ReadCloser) </span><span class="cov0" title="0">{
                        err := gzipBody.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("internal server error", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                }(gzBody)
                <span class="cov0" title="0">zr, err := gzip.NewReader(gzBody)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("internal server error", zap.Error(err))
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">r.Body = zr
                next.ServeHTTP(w, r)</span>
        })
}

// CompressResponseMiddleware compresses outgoing HTTP responses.
func (h *Handler) CompressResponseMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !strings.Contains(r.Header.Get("Accept-Encoding"), `gzip`) </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov0" title="0">cw := compress.NewCompressWriter(w)
                defer func() </span><span class="cov0" title="0">{
                        if err := cw.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("internal server error", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                }()
                <span class="cov0" title="0">w.Header().Set("Content-Encoding", `gzip`)

                next.ServeHTTP(cw, r)</span>
        })
}

// WithHash adds request hashing to the handler chain.
func (h *Handler) WithHash(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Header.Get(hash.Header) != "" &amp;&amp; h.config.Key != "" </span><span class="cov0" title="0">{
                        bodyBytes, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "error reading request body", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">if hash.Encode(bodyBytes, h.config.Key) != r.Header.Get(hash.Header) </span><span class="cov0" title="0">{
                                http.Error(w, "incorrect hash", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))</span>
                }
                <span class="cov0" title="0">hw := &amp;hash.Writer{
                        ResponseWriter: w,
                        Key:            h.config.Key,
                        RHash:          r.Header.Get(hash.Header),
                }
                next.ServeHTTP(hw, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package rest provides RESTful API handlers for managing metrics.
package rest

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/http/pprof"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "go.uber.org/zap"

        "metrics/internal/server/config"
        "metrics/internal/server/core/domain"
        "metrics/internal/server/logger"
)

// Constants for metric-related fields.
const (
        metricType  = "metricType"
        metricValue = "metricValue"
        metricName  = "metricName"

        contentType   = "Content-Type"
        serverTimeout = 3
)

// MetricService defines the interface for metric operations.
type MetricService interface {
        // GetMetric retrieves a specific metric based on its type and name
        GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error)

        // GetMetricValue retrieves the value of a specific metric.
        GetMetricValue(ctx context.Context, mType, mName string) (string, error)

        // SetMetric creates or updates a metric.
        SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error)

        // SetMetrics sets multiple metrics at once.
        SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error)

        // SetMetricValue sets the value of an existing metric.
        SetMetricValue(ctx context.Context, m *domain.SetMetricRequest) (*domain.Metric, error)

        // GetAllMetrics retrieves all available metrics.
        GetAllMetrics(ctx context.Context) (domain.MetricsList, error)

        // Ping checks the health of the storage system.
        Ping(ctx context.Context) error
}

// Handler represents the handler for API operations.
type Handler struct {
        metricService MetricService
        config        *config.Config
}

type API struct {
        srv *http.Server
}

// Run starts the HTTP server.
func (a *API) Run() error <span class="cov0" title="0">{
        sigint := make(chan os.Signal, 1)
        signal.Notify(sigint, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigint
                if err := a.srv.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("server shutdown: ", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">if err := a.srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error occurred during running server: ", zap.Error(err))
                return fmt.Errorf("failed run server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewAPI creates a new instance of the API.
func NewAPI(metricService MetricService, cfg *config.Config) *API <span class="cov0" title="0">{
        h := &amp;Handler{
                metricService: metricService,
                config:        cfg,
        }
        r := chi.NewRouter()

        r.Use(h.LoggingRequestMiddleware)
        r.Use(h.WithHash)
        r.Use(h.CompressRequestMiddleware)
        r.Use(h.CompressResponseMiddleware)
        r.Use(middleware.Timeout(serverTimeout * time.Second))

        r.HandleFunc("/debug/pprof", pprof.Index)
        r.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
        r.HandleFunc("/debug/pprof/profile", pprof.Profile)
        r.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
        r.HandleFunc("/debug/pprof/trace", pprof.Trace)

        r.Handle("/debug/pprof/block", pprof.Handler("block"))
        r.Handle("/debug/pprof/goroutine", pprof.Handler("goroutine"))
        r.Handle("/debug/pprof/heap", pprof.Handler("heap"))
        r.Handle("/debug/pprof/threadcreate", pprof.Handler("threadcreate"))

        r.Route("/update", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", h.SetMetric)
                r.Post("/{metricType}/{metricName}/{metricValue}", h.SetMetricValue)
        }</span>)
        <span class="cov0" title="0">r.Route("/value", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", h.GetMetric)
                r.Get("/{metricType}/{metricName}", h.GetMetricValue)
        }</span>)
        <span class="cov0" title="0">r.Post("/updates/", h.SetMetrics)
        r.Get("/", h.GetAllMetrics)
        r.Get("/ping", h.Ping)
        return &amp;API{
                srv: &amp;http.Server{
                        Addr:    cfg.Address,
                        Handler: r,
                },
        }</span>
}

// SetMetricValue handles POST requests to update metric values.
func (h *Handler) SetMetricValue(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        mType := chi.URLParam(req, metricType)
        mName := chi.URLParam(req, metricName)
        mValue := chi.URLParam(req, metricValue)
        _, err := h.metricService.SetMetricValue(req.Context(), &amp;domain.SetMetricRequest{
                ID:    mName,
                MType: mType,
                Value: mValue,
        })
        if err != nil </span><span class="cov8" title="1">{
                logger.Log.Error("failed to set metric",
                        zap.String(metricValue, mValue),
                        zap.String(metricType, mType),
                        zap.String(metricName, mName),
                        zap.Error(err),
                )
                handleSetMetricError(w, err)
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

// SetMetric handles POST requests to set or update metrics.
func (h *Handler) SetMetric(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var m domain.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;m); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("cannot decode request JSON body", zap.Error(err))
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(io.Discard, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("cannot read body", zap.Error(err))
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">err = req.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("cannot close body", zap.Error(err))
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">metric, err := h.metricService.SetMetric(req.Context(), &amp;m)

        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to set metric", zap.Error(err))
                handleSetMetricError(w, err)
                return
        }</span>
        <span class="cov0" title="0">w.Header().Set(contentType, "application/json")

        if err = json.NewEncoder(w).Encode(metric); err != nil </span><span class="cov0" title="0">{
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                logger.Log.Error("error encoding response", zap.Error(err))
                return
        }</span>
}

// SetMetrics handles POST requests to set multiple metrics at once.
func (h *Handler) SetMetrics(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var metricsIn domain.MetricsList
        if err := json.NewDecoder(req.Body).Decode(&amp;metricsIn); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(io.Discard, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("cannot read body", zap.Error(err))
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">err = req.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("cannot close body", zap.Error(err))
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">metricsOut, err := h.metricService.SetMetrics(req.Context(), metricsIn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to set metric", zap.Error(err))
                handleSetMetricError(w, err)
                return
        }</span>
        <span class="cov0" title="0">w.Header().Set(contentType, "application/json")

        if err = json.NewEncoder(w).Encode(metricsOut); err != nil </span><span class="cov0" title="0">{
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                logger.Log.Error("error encoding response", zap.Error(err))
                return
        }</span>
}

// GetMetricValue handles GET requests to retrieve metric values.
func (h *Handler) GetMetricValue(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        mType, mName := chi.URLParam(req, metricType), chi.URLParam(req, metricName)
        metricValue, err := h.metricService.GetMetricValue(req.Context(), mType, mName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to get metric",
                        zap.String(metricType, mType),
                        zap.String(metricName, mName),
                        zap.Error(err),
                )
                handleGetMetricError(w, err)
                return
        }</span>
        <span class="cov0" title="0">if _, err := w.Write([]byte(metricValue)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

// GetMetric handles GET requests to retrieve metrics based on type and name.
func (h *Handler) GetMetric(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var m domain.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;m); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("cannot decode request JSON body", zap.Error(err))
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">metric, err := h.metricService.GetMetric(req.Context(), m.MType, m.ID)

        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to get metric", zap.Error(err))
                handleGetMetricError(w, err)

                return
        }</span>
        <span class="cov0" title="0">w.Header().Set(contentType, "application/json")
        enc := json.NewEncoder(w)
        if err := enc.Encode(metric); err != nil </span><span class="cov0" title="0">{
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                logger.Log.Error("error encoding response", zap.Error(err))
                return
        }</span>
}

// GetAllMetrics handles GET requests to retrieve all available metrics.
func (h *Handler) GetAllMetrics(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        metrics, err := h.metricService.GetAllMetrics(req.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                logger.Log.Error("failed to get all metrics", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">html := "&lt;html&gt;&lt;body&gt;&lt;ul&gt;"
        for _, metric := range metrics </span><span class="cov0" title="0">{
                switch metric.MType </span>{
                case domain.Gauge:<span class="cov0" title="0">
                        if metric.Value != nil </span><span class="cov0" title="0">{
                                html += fmt.Sprintf("&lt;li&gt;mType: %s, mName: %s, Value %v", metric.MType, metric.ID, *metric.Value)
                        }</span>
                case domain.Counter:<span class="cov0" title="0">
                        if metric.Delta != nil </span><span class="cov0" title="0">{
                                html += fmt.Sprintf("&lt;li&gt;mType: %s, mName: %s, Value %v", metric.MType, metric.ID, *metric.Delta)
                        }</span>
                }
        }
        <span class="cov0" title="0">html += "&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;"
        w.Header().Set(contentType, "text/html")
        if _, err := w.Write([]byte(html)); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>
}

// Ping handles GET requests to check the health of the storage system.
func (h *Handler) Ping(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        err := h.metricService.Ping(req.Context())
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("failed to ping storage", zap.Error(err))
                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "embed"
        "errors"
        "fmt"
        "metrics/internal/server/logger"

        "github.com/jmoiron/sqlx"
        "github.com/pressly/goose/v3"
)

//go:embed migrations
var migrations embed.FS

func migrate(db *sqlx.DB) error <span class="cov0" title="0">{
        goose.SetBaseFS(migrations)

        if err := goose.SetDialect("postgres"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("postgres migrate set dialect postgres: %w", err)
        }</span>

        <span class="cov0" title="0">if err := goose.Up(db.DB, "migrations"); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, goose.ErrNoNextVersion) </span><span class="cov0" title="0">{
                        return fmt.Errorf("postgres migrate up: %w", err)
                }</span>
        }
        <span class="cov0" title="0">logger.Log.Info("successful migrations")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "metrics/internal/server/core/domain"
        "metrics/internal/server/logger"
        "metrics/internal/shared-kernel/retrying"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"
)

type MetricStorage struct {
        db *sqlx.DB
}

func NewStorage(cfg *Config) (*MetricStorage, error) <span class="cov0" title="0">{
        db, err := sqlx.Open("pgx", cfg.DSN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database %w", err)
        }</span>
        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;MetricStorage{db: db}, migrate(db)</span>
}

func (s *MetricStorage) GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error) <span class="cov0" title="0">{
        var (
                delta sql.NullInt64
                value sql.NullFloat64
        )
        row := s.db.QueryRowContext(
                ctx,
                `select delta, value from metrics where name=$1 and type=$2 ORDER BY created_at DESC LIMIT 1;`,
                mName,
                mType,
        )
        if row.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w", row.Err())
        }</span>
        <span class="cov0" title="0">if err := row.Scan(&amp;delta, &amp;value); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, domain.ErrItemNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("%w", err)</span>
        }
        <span class="cov0" title="0">switch mType </span>{
        case domain.Gauge:<span class="cov0" title="0">
                return &amp;domain.Metric{ID: mName, MType: mType, Value: &amp;value.Float64}, nil</span>
        case domain.Counter:<span class="cov0" title="0">
                return &amp;domain.Metric{ID: mName, MType: mType, Delta: &amp;delta.Int64}, nil</span>
        default:<span class="cov0" title="0">
                return nil, domain.ErrIncorrectMetricType</span>
        }
}

func (s *MetricStorage) SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error) <span class="cov0" title="0">{
        switch m.MType </span>{
        case domain.Gauge:<span class="cov0" title="0">
                err := retrying.ExecContext(
                        ctx,
                        s.db,
                        `INSERT INTO metrics (name, type, value) VALUES ($1, $2, $3)`,
                        m.ID, m.MType, *m.Value,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w", err)
                }</span>
        case domain.Counter:<span class="cov0" title="0">
                current, err := s.GetMetric(ctx, m.MType, m.ID)
                if err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, domain.ErrItemNotFound) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        *m.Delta += *current.Delta
                }</span>
                <span class="cov0" title="0">err = retrying.ExecContext(
                        ctx,
                        s.db,
                        `INSERT INTO metrics (name, type, delta) VALUES ($1, $2, $3)`,
                        m.ID, m.MType, *m.Delta,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, domain.ErrIncorrectMetricType</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (s *MetricStorage) SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error) <span class="cov0" title="0">{
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">for _, m := range metrics </span><span class="cov0" title="0">{
                switch m.MType </span>{
                case domain.Gauge:<span class="cov0" title="0">
                        err = retrying.ExecContext(
                                ctx,
                                s.db,
                                `INSERT INTO metrics (name, type, value) VALUES ($1, $2, $3)`,
                                m.ID, m.MType, *m.Value,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                if txErr := tx.Rollback(); txErr != nil </span><span class="cov0" title="0">{
                                        if !errors.Is(txErr, sql.ErrTxDone) </span><span class="cov0" title="0">{
                                                logger.Log.Error("failed to rollback the transaction", zap.Error(txErr))
                                        }</span>
                                }
                                <span class="cov0" title="0">return nil, fmt.Errorf("%w", err)</span>
                        }

                case domain.Counter:<span class="cov0" title="0">
                        current, err := s.GetMetric(ctx, m.MType, m.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                if !errors.Is(err, domain.ErrItemNotFound) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("%w", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                *m.Delta += *current.Delta
                        }</span>
                        <span class="cov0" title="0">err = retrying.ExecContext(
                                ctx,
                                s.db,
                                `INSERT INTO metrics (name, type, delta) VALUES ($1, $2, $3)`,
                                m.ID, m.MType, *m.Delta,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                if txErr := tx.Rollback(); txErr != nil </span><span class="cov0" title="0">{
                                        if !errors.Is(txErr, sql.ErrTxDone) </span><span class="cov0" title="0">{
                                                logger.Log.Error("failed to rollback the transaction", zap.Error(txErr))
                                        }</span>
                                }
                                <span class="cov0" title="0">return nil, fmt.Errorf("%w", err)</span>
                        }
                default:<span class="cov0" title="0">
                        return nil, domain.ErrIncorrectMetricType</span>
                }
        }

        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction %w", err)
        }</span>
        <span class="cov0" title="0">return metrics, nil</span>
}

func (s *MetricStorage) GetAllMetrics(ctx context.Context) (domain.MetricsList, error) <span class="cov0" title="0">{
        metrics := make(domain.MetricsList, 0)
        rows, err := s.db.QueryContext(ctx,
                `SELECT t1.name, t1.type, m.delta, m.value 
                    FROM (select name, type, MAX(created_at) as created_at from metrics group by name, type) AS t1
                        LEFT JOIN metrics AS m ON t1.name = m.name AND t1.type=m.type AND t1.created_at = m.created_at;`,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var (
                        m     domain.Metric
                        delta sql.NullInt64
                        value sql.NullFloat64
                )

                err = rows.Scan(&amp;m.ID, &amp;m.MType, &amp;delta, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w", err)
                }</span>
                <span class="cov0" title="0">switch m.MType </span>{
                case domain.Gauge:<span class="cov0" title="0">
                        m.Value = &amp;value.Float64</span>
                case domain.Counter:<span class="cov0" title="0">
                        m.Delta = &amp;delta.Int64</span>
                default:<span class="cov0" title="0">
                        return nil, domain.ErrIncorrectMetricType</span>
                }

                <span class="cov0" title="0">metrics = append(metrics, m)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error occurred during closing rows", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return metrics, nil</span>
}

func (s *MetricStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if err := s.db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package file

import (
        "context"
        "fmt"
        "metrics/internal/server/core/files"
        "sync"

        "metrics/internal/server/core/domain"
)

type InMemoryStore struct {
        mux     *sync.RWMutex
        metrics map[domain.Key]domain.Value
}

type MetricStorage struct {
        InMemoryStore
        filepath  string
        syncWrite bool
}

func NewStorage(cfg *Config) (*MetricStorage, error) <span class="cov0" title="0">{
        inMemoryStore := InMemoryStore{
                mux:     &amp;sync.RWMutex{},
                metrics: make(map[domain.Key]domain.Value),
        }
        if cfg.StoreInterval == 0 </span><span class="cov0" title="0">{
                return &amp;MetricStorage{
                        inMemoryStore,
                        cfg.Filepath,
                        true,
                }, nil
        }</span> else<span class="cov0" title="0"> {
                return &amp;MetricStorage{
                        inMemoryStore,
                        cfg.Filepath,
                        false,
                }, nil
        }</span>
}

func (s *MetricStorage) SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error) <span class="cov0" title="0">{
        s.saveMetric(m)
        if s.syncWrite </span><span class="cov0" title="0">{
                err := files.SaveMetricsToFile(s.filepath, s.metrics)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save metrics to file %w", err)
                }</span>
        }
        <span class="cov0" title="0">metric, err := s.GetMetric(ctx, m.MType, m.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get metric %w", err)
        }</span>
        <span class="cov0" title="0">return metric, nil</span>
}

func (s *MetricStorage) SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error) <span class="cov0" title="0">{
        for _, metric := range metrics </span><span class="cov0" title="0">{
                s.saveMetric(&amp;metric)
        }</span>
        <span class="cov0" title="0">if s.syncWrite </span><span class="cov0" title="0">{
                err := files.SaveMetricsToFile(s.filepath, s.metrics)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save metrics to file %w", err)
                }</span>
        }
        <span class="cov0" title="0">metricsOut := make(domain.MetricsList, 0)
        for _, metric := range metrics </span><span class="cov0" title="0">{
                m, err := s.GetMetric(ctx, metric.MType, metric.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get metric %w", err)
                }</span>
                <span class="cov0" title="0">if m != nil </span><span class="cov0" title="0">{
                        metricsOut = append(metricsOut, *m)
                }</span>
        }
        <span class="cov0" title="0">return metricsOut, nil</span>
}

func (s *MetricStorage) GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error) <span class="cov0" title="0">{
        s.mux.RLock()
        defer s.mux.RUnlock()
        value, found := s.metrics[domain.Key{MType: mType, ID: mName}]
        if !found </span><span class="cov0" title="0">{
                return &amp;domain.Metric{}, domain.ErrItemNotFound
        }</span>
        <span class="cov0" title="0">return &amp;domain.Metric{
                ID:    mName,
                MType: mType,
                Value: value.Value,
                Delta: value.Delta,
        }, nil</span>
}

func (s *MetricStorage) GetAllMetrics(ctx context.Context) (domain.MetricsList, error) <span class="cov0" title="0">{
        s.mux.RLock()
        defer s.mux.RUnlock()
        metrics := make(domain.MetricsList, 0)
        for k, v := range s.metrics </span><span class="cov0" title="0">{
                metrics = append(metrics, domain.Metric{
                        ID:    k.ID,
                        MType: k.MType,
                        Value: v.Value,
                        Delta: v.Delta,
                })
        }</span>
        <span class="cov0" title="0">return metrics, nil</span>
}

func (s *MetricStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *MetricStorage) saveMetric(m *domain.Metric) <span class="cov0" title="0">{
        s.mux.Lock()
        defer s.mux.Unlock()
        key := domain.Key{MType: m.MType, ID: m.ID}
        if m.MType == domain.Counter </span><span class="cov0" title="0">{
                value, found := s.metrics[key]
                if found </span><span class="cov0" title="0">{
                        *value.Delta += *m.Delta
                        s.metrics[key] = domain.Value{Delta: value.Delta}
                }</span> else<span class="cov0" title="0"> {
                        s.metrics[key] = domain.Value{Delta: m.Delta}
                }</span>
        } else<span class="cov0" title="0"> {
                s.metrics[key] = domain.Value{Value: m.Value}
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package memory

import (
        "context"
        "sync"

        "metrics/internal/server/core/domain"
)

type MetricStorage struct {
        mux     *sync.Mutex
        metrics map[domain.Key]domain.Value
}

func NewStorage(cfg *Config) (*MetricStorage, error) <span class="cov8" title="1">{
        return &amp;MetricStorage{
                mux:     &amp;sync.Mutex{},
                metrics: make(map[domain.Key]domain.Value),
        }, nil
}</span>

func (s *MetricStorage) GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error) <span class="cov8" title="1">{
        s.mux.Lock()
        defer s.mux.Unlock()
        value, found := s.metrics[domain.Key{MType: mType, ID: mName}]
        if !found </span><span class="cov0" title="0">{
                return &amp;domain.Metric{}, domain.ErrItemNotFound
        }</span>
        <span class="cov8" title="1">return &amp;domain.Metric{
                ID:    mName,
                MType: mType,
                Value: value.Value,
                Delta: value.Delta,
        }, nil</span>
}

func (s *MetricStorage) SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error) <span class="cov8" title="1">{
        s.mux.Lock()
        defer s.mux.Unlock()
        s.saveMetric(m)
        return m, nil
}</span>

func (s *MetricStorage) SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error) <span class="cov8" title="1">{
        s.mux.Lock()
        defer s.mux.Unlock()
        for _, metric := range metrics </span><span class="cov8" title="1">{
                s.saveMetric(&amp;metric)
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}

func (s *MetricStorage) GetAllMetrics(ctx context.Context) (domain.MetricsList, error) <span class="cov8" title="1">{
        s.mux.Lock()
        defer s.mux.Unlock()
        metrics := make(domain.MetricsList, 0)
        for k, v := range s.metrics </span><span class="cov8" title="1">{
                metrics = append(metrics, domain.Metric{
                        ID:    k.ID,
                        MType: k.MType,
                        Value: v.Value,
                        Delta: v.Delta,
                })
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}

func (s *MetricStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *MetricStorage) saveMetric(m *domain.Metric) <span class="cov8" title="1">{
        key := domain.Key{MType: m.MType, ID: m.ID}
        if m.MType == domain.Counter </span><span class="cov8" title="1">{
                value, found := s.metrics[key]
                if found </span><span class="cov8" title="1">{
                        *value.Delta += *m.Delta
                        s.metrics[key] = domain.Value{Delta: value.Delta}
                }</span> else<span class="cov8" title="1"> {
                        s.metrics[key] = domain.Value{Delta: m.Delta}
                }</span>
        } else<span class="cov8" title="1"> {
                s.metrics[key] = domain.Value{Value: m.Value}
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package storage provides implementations of the MetricStorage interface
// for different storage adapters.
//
// It offers three types of storage:
// - Database storage
// - Memory storage
// - File storage
//
// Users can configure which storage adapter to use through the Config parameter.

package storage

import (
        "context"
        "errors"
        "fmt"
        "metrics/internal/server/adapters/storage/database"

        "metrics/internal/server/adapters/storage/file"
        "metrics/internal/server/adapters/storage/memory"
        "metrics/internal/server/core/domain"
)

// MetricStorage defines the interface for metric storage operations.
type MetricStorage interface {
        // GetMetric retrieves a specific metric based on its type and name.
        GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error)

        // SetMetric adds or updates a metric.
        SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error)

        // GetAllMetrics retrieves all stored metrics.
        GetAllMetrics(ctx context.Context) (domain.MetricsList, error)

        // SetMetrics bulk inserts or updates multiple metrics.
        SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error)

        // Ping checks the health of the storage adapter.
        Ping(ctx context.Context) error
}

// NewStorage creates a new MetricStorage instance based on the provided configuration.
//
// It supports three types of storage adapters:
// - Database storage
// - Memory storage
// - File storage
//
// If no valid storage adapter is specified, it returns an error.
func NewStorage(cfg Config) (MetricStorage, error) <span class="cov8" title="1">{
        if cfg.Database != nil </span><span class="cov0" title="0">{
                storage, err := database.NewStorage(cfg.Database)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w", err)
                }</span>
                <span class="cov0" title="0">return storage, nil</span>
        }
        <span class="cov8" title="1">if cfg.Memory != nil </span><span class="cov8" title="1">{
                storage, err := memory.NewStorage(cfg.Memory)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w", err)
                }</span>
                <span class="cov8" title="1">return storage, nil</span>
        }
        <span class="cov0" title="0">if cfg.File != nil </span><span class="cov0" title="0">{
                storage, err := file.NewStorage(cfg.File)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w", err)
                }</span>
                <span class="cov0" title="0">return storage, nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("no available storage")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package config

import (
        "flag"
        "fmt"

        "github.com/caarlos0/env/v11"
)

const (
        storeInterval = 300
)

type Config struct {
        Address         string `env:"ADDRESS"`
        StoreInterval   int    `env:"STORE_INTERVAL"`
        DatabaseDSN     string `env:"DATABASE_DSN"`
        FileStoragePath string `env:"FILE_STORAGE_PATH"`
        Key             string `env:"KEY"`
        Restore         bool   `env:"RESTORE"`
        LogLevel        string
}

func NewConfig() (*Config, error) <span class="cov0" title="0">{
        var cfg Config
        flag.StringVar(&amp;cfg.Address, "a", ":8080", "port to run server")
        flag.IntVar(&amp;cfg.StoreInterval, "i", storeInterval, "time interval (seconds) to backup server data")
        flag.StringVar(&amp;cfg.FileStoragePath, "f", "/tmp/metrics-db.json", "where to store server data")
        flag.StringVar(&amp;cfg.DatabaseDSN, "d", "", "database dsn")
        flag.StringVar(&amp;cfg.Key, "k", "", "hashing key")
        flag.BoolVar(&amp;cfg.Restore, "r", true, "recover data from files")
        flag.StringVar(&amp;cfg.LogLevel, "l", "info", "log level")
        flag.Parse()

        err := env.Parse(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, fmt.Errorf("failed to get config for server: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package files provides functionality for saving and loading metrics to/from files.
package files

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"

        "metrics/internal/server/core/domain"
        "metrics/internal/server/logger"

        "go.uber.org/zap"
)

// SaveMetricsToFile saves the given metrics to a file.
//
// Args:
//
//        filepath (string): The path to save the metrics file.
//        metrics (domain.MetricValues): The metrics to save.
//
// Returns:
//
//        error: Any error that occurred during the operation.
func SaveMetricsToFile(filepath string, metrics domain.MetricValues) error <span class="cov8" title="1">{
        file, err := os.Create(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create a file %w", err)
        }</span>
        <span class="cov8" title="1">defer func(f *os.File) </span><span class="cov8" title="1">{
                if err = f.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("failed to close file: %w", zap.Error(err))
                }</span>
        }(file)
        <span class="cov8" title="1">metricList := make(domain.MetricsList, 0)
        for k, v := range metrics </span><span class="cov8" title="1">{
                metricList = append(metricList, domain.Metric{
                        ID:    k.ID,
                        MType: k.MType,
                        Value: v.Value,
                        Delta: v.Delta,
                })
        }</span>
        <span class="cov8" title="1">if err = json.NewEncoder(file).Encode(metricList); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LoadMetricsFromFile loads metrics from a file.
//
// Args:
//
//        filepath (string): The path to load the metrics file from.
//
// Returns:
//
//        domain.MetricValues: The loaded metrics.
//        error: Any error that occurred during the operation.
func LoadMetricsFromFile(filepath string) (domain.MetricValues, error) <span class="cov8" title="1">{
        var (
                metricList domain.MetricsList
        )
        if _, err := os.Stat(filepath); errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                f, err := os.Create(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create file: %w", err)
                }</span>
                <span class="cov0" title="0">err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to close file: %w", err)
                }</span>
        }
        <span class="cov8" title="1">data, err := os.ReadFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>
        <span class="cov8" title="1">if err = json.NewDecoder(bytes.NewReader(data)).Decode(&amp;metricList); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode file: %w", err)
                }</span>
                <span class="cov0" title="0">return make(domain.MetricValues), nil</span>
        }
        <span class="cov8" title="1">metricValues := make(domain.MetricValues)
        for _, v := range metricList </span><span class="cov8" title="1">{
                metricValues[domain.Key{MType: v.MType, ID: v.ID}] = domain.Value{Value: v.Value, Delta: v.Delta}
        }</span>
        <span class="cov8" title="1">return metricValues, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mocks

import (
        "context"
        "metrics/internal/server/core/domain"
        "reflect"

        "github.com/golang/mock/gomock"
)

type MockServicerMockRecorder struct {
        mock *MockServicer
}
type MockServicer struct {
        ctrl     *gomock.Controller
        recorder *MockServicerMockRecorder
}

func NewMockService(ctrl *gomock.Controller) *MockServicer <span class="cov0" title="0">{
        mock := &amp;MockServicer{ctrl: ctrl}
        mock.recorder = &amp;MockServicerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (ms *MockServicer) EXPECT() *MockServicerMockRecorder <span class="cov0" title="0">{
        return ms.recorder
}</span>

func (ms *MockServicer) GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error) <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(ms, "GetMetric", ctx, mType, mName)
        ret0, _ := ret[0].(domain.Metric)
        ret1, _ := ret[1].(error)
        return &amp;ret0, ret1
}</span>

func (mr *MockServicerMockRecorder) GetMetric(ctx, mType, mName interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetric", reflect.TypeOf((*MockServicer)(nil).GetMetric), ctx, mType, mName)
}</span>

func (ms *MockServicer) GetAllMetrics(ctx context.Context) (domain.MetricsList, error) <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(ms, "GetAllMetrics", ctx)
        ret0, _ := ret[0].(domain.MetricsList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

func (mr *MockServicerMockRecorder) GetAllMetrics(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllMetrics", reflect.TypeOf((*MockServicer)(nil).GetAllMetrics), ctx)
}</span>

func (ms *MockServicer) GetMetricValue(ctx context.Context, mType, mName string) (string, error) <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(ms, "GetMetricValue", ctx, mType, mName)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

func (mr *MockServicerMockRecorder) GetMetricValue(ctx, mType, mName interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetricValue", reflect.TypeOf((*MockServicer)(nil).GetMetricValue), ctx, mType, mName)
}</span>

func (ms *MockServicer) SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error) <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(m, "SetMetric", ctx, m)
        ret0, _ := ret[0].(domain.Metric)
        ret1, _ := ret[1].(error)
        return &amp;ret0, ret1
}</span>

func (mr *MockServicerMockRecorder) SetMetric(ctx, m interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMetric", reflect.TypeOf((*MockServicer)(nil).SetMetric), ctx, m)
}</span>

func (ms *MockServicer) SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error) <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(metrics, "SetMetrics", ctx, metrics)
        ret0, _ := ret[0].(domain.MetricsList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

func (mr *MockServicerMockRecorder) SetMetrics(ctx, m interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMetrics", reflect.TypeOf((*MockServicer)(nil).SetMetrics), ctx, m)
}</span>

func (ms *MockServicer) SetMetricValue(ctx context.Context, m *domain.SetMetricRequest) (*domain.Metric, error) <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(m, "SetMetricValue", ctx, m)
        ret0, _ := ret[0].(domain.Metric)
        ret1, _ := ret[1].(error)
        return &amp;ret0, ret1
}</span>

func (mr *MockServicerMockRecorder) SetMetricValue(ctx, m interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMetricValue", reflect.TypeOf((*MockServicer)(nil).SetMetricValue), ctx, m)
}</span>

func (ms *MockServicer) Ping(ctx context.Context) error <span class="cov0" title="0">{
        ms.ctrl.T.Helper()
        ret := ms.ctrl.Call(ms, "Ping", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

func (mr *MockServicerMockRecorder) Ping(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockServicer)(nil).Ping), ctx)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package service provides functionality for managing metrics.
package service

import (
        "context"
        "fmt"
        "metrics/internal/server/core/domain"
        "metrics/internal/server/core/files"
        "strconv"
)

// MetricStorage defines the interface for metric storage operations.
type MetricStorage interface {
        // GetMetric retrieves a specific metric based on type and name.
        GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error)

        // SetMetric sets a single metric.
        SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error)

        // SetMetrics sets multiple metrics at once.
        SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error)

        // GetAllMetrics retrieves all stored metrics.
        GetAllMetrics(ctx context.Context) (domain.MetricsList, error)

        // Ping checks the health of the storage system.
        Ping(ctx context.Context) error
}

// MetricService represents the main service for managing metrics.
type MetricService struct {
        storage  MetricStorage
        filepath string
}

// NewMetricService creates a new instance of MetricService.
func NewMetricService(filepath string, storage MetricStorage) (*MetricService, error) <span class="cov8" title="1">{
        ms := MetricService{
                storage:  storage,
                filepath: filepath,
        }
        return &amp;ms, nil
}</span>

// GetMetric retrieves a specific metric based on type and name.
func (ms *MetricService) GetMetric(ctx context.Context, mType, mName string) (*domain.Metric, error) <span class="cov8" title="1">{
        metric, err := ms.storage.GetMetric(ctx, mType, mName)
        if err != nil </span><span class="cov0" title="0">{
                return metric, fmt.Errorf("failed to get metric: %w", err)
        }</span>
        <span class="cov8" title="1">return metric, nil</span>
}

// SetMetric sets a single metric based on its type.
func (ms *MetricService) SetMetric(ctx context.Context, m *domain.Metric) (*domain.Metric, error) <span class="cov8" title="1">{
        switch m.MType </span>{
        case domain.Gauge:<span class="cov8" title="1">
                if m.Value == nil </span><span class="cov0" title="0">{
                        return nil, domain.ErrNilGaugeValue
                }</span>
                <span class="cov8" title="1">metric, err := ms.storage.SetMetric(ctx, m)
                if err != nil </span><span class="cov0" title="0">{
                        return metric, fmt.Errorf("%w", err)
                }</span>
                <span class="cov8" title="1">return metric, nil</span>
        case domain.Counter:<span class="cov0" title="0">
                if m.Delta == nil </span><span class="cov0" title="0">{
                        return nil, domain.ErrNilCounterDelta
                }</span>
                <span class="cov0" title="0">metric, err := ms.storage.SetMetric(ctx, m)
                if err != nil </span><span class="cov0" title="0">{
                        return metric, fmt.Errorf("%w", err)
                }</span>
                <span class="cov0" title="0">return metric, nil</span>
        default:<span class="cov0" title="0">
                return &amp;domain.Metric{}, domain.ErrIncorrectMetricType</span>
        }
}

// SetMetrics sets multiple metrics at once.
func (ms *MetricService) SetMetrics(ctx context.Context, metrics domain.MetricsList) (domain.MetricsList, error) <span class="cov8" title="1">{
        metrics, err := ms.storage.SetMetrics(ctx, metrics)
        if err != nil </span><span class="cov0" title="0">{
                return metrics, fmt.Errorf("%w", err)
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}

// SetMetricValue sets a metric value based on the provided request.
func (ms *MetricService) SetMetricValue(ctx context.Context, req *domain.SetMetricRequest) (*domain.Metric, error) <span class="cov8" title="1">{
        switch req.MType </span>{
        case domain.Gauge:<span class="cov8" title="1">
                value, err := strconv.ParseFloat(req.Value, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;domain.Metric{}, domain.ErrIncorrectMetricValue
                }</span>
                <span class="cov8" title="1">metric, err := ms.storage.SetMetric(ctx, &amp;domain.Metric{
                        ID:    req.ID,
                        MType: req.MType,
                        Value: &amp;value,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return metric, fmt.Errorf("%w", err)
                }</span>
                <span class="cov8" title="1">return metric, nil</span>
        case domain.Counter:<span class="cov0" title="0">
                value, err := strconv.Atoi(req.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;domain.Metric{}, domain.ErrIncorrectMetricValue
                }</span>
                <span class="cov0" title="0">valueInt := int64(value)
                metric, err := ms.storage.SetMetric(ctx, &amp;domain.Metric{
                        ID:    req.ID,
                        MType: req.MType,
                        Delta: &amp;valueInt,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return metric, fmt.Errorf("%w", err)
                }</span>
                <span class="cov0" title="0">return metric, nil</span>
        default:<span class="cov0" title="0">
                return &amp;domain.Metric{}, domain.ErrIncorrectMetricType</span>
        }
}

// GetMetricValue retrieves the value of a metric based on its type and name.
func (ms *MetricService) GetMetricValue(ctx context.Context, mType, mName string) (string, error) <span class="cov8" title="1">{
        metric, err := ms.storage.GetMetric(ctx, mType, mName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w", err)
        }</span>
        <span class="cov8" title="1">switch mType </span>{
        case domain.Gauge:<span class="cov8" title="1">
                value := strconv.FormatFloat(*metric.Value, 'f', -1, 64)
                return value, nil</span>
        case domain.Counter:<span class="cov0" title="0">
                value := strconv.Itoa(int(*metric.Delta))
                return value, nil</span>
        default:<span class="cov0" title="0">
                return "", domain.ErrIncorrectMetricType</span>
        }
}

// GetAllMetrics retrieves all stored metrics.
func (ms *MetricService) GetAllMetrics(ctx context.Context) (domain.MetricsList, error) <span class="cov8" title="1">{
        metrics, err := ms.storage.GetAllMetrics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w", err)
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}

// Ping checks the health of the storage system.
func (ms *MetricService) Ping(ctx context.Context) error <span class="cov0" title="0">{
        err := ms.storage.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SaveMetrics saves all metrics to a file.
func (ms *MetricService) SaveMetrics() error <span class="cov8" title="1">{
        metricValues := make(domain.MetricValues)
        metrics, err := ms.storage.GetAllMetrics(context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get metrics for saving to file: %w", err)
        }</span>
        <span class="cov8" title="1">for _, v := range metrics </span><span class="cov8" title="1">{
                metricValues[domain.Key{ID: v.ID, MType: v.MType}] = domain.Value{Value: v.Value, Delta: v.Delta}
        }</span>
        <span class="cov8" title="1">err = files.SaveMetricsToFile(ms.filepath, metricValues)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save metrics to file: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LoadMetrics loads all metrics from a file.
func (ms *MetricService) LoadMetrics() error <span class="cov8" title="1">{
        metrics, err := files.LoadMetricsFromFile(ms.filepath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load metrics for restore: %w", err)
        }</span>
        <span class="cov8" title="1">for k, v := range metrics </span><span class="cov8" title="1">{
                _, err = ms.storage.SetMetric(context.TODO(), &amp;domain.Metric{
                        ID:    k.ID,
                        MType: k.MType,
                        Value: v.Value,
                        Delta: v.Delta,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save metrics in restore: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package logger

import (
        "fmt"

        "go.uber.org/zap"
)

var Log *zap.Logger = zap.NewNop()

func Initialize(level string) error <span class="cov0" title="0">{
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse log level: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := zap.NewProductionConfig()
        cfg.Level = lvl
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build log config: %w", err)
        }</span>
        <span class="cov0" title="0">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package compress

import (
        "bytes"
        "compress/gzip"
        "fmt"
        "net/http"
)

// Writer wraps an http.ResponseWriter with gzip compression capabilities.
type Writer struct {
        http.ResponseWriter
        zw *gzip.Writer
}

// NewCompressWriter creates a new gzip Writer that wraps the provided http.ResponseWriter.
func NewCompressWriter(w http.ResponseWriter) *Writer <span class="cov0" title="0">{
        return &amp;Writer{
                w,
                gzip.NewWriter(w),
        }
}</span>

// Write implements the io.Writer interface for the Writer.
func (c *Writer) Write(p []byte) (int, error) <span class="cov0" title="0">{
        n, err := c.zw.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return n, nil</span>
}

// Close closes the underlying gzip writer.
func (c *Writer) Close() error <span class="cov0" title="0">{
        err := c.zw.Close()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GzipData compresses the provided data using gzip compression.
func GzipData(data []byte) ([]byte, error) <span class="cov0" title="0">{
        var b bytes.Buffer
        gz := gzip.NewWriter(&amp;b)
        _, err := gz.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">err = gz.Close()
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return b.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package hash

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "net/http"
)

// Header is the header name used for storing HMAC hashes in HTTP responses.
const Header = "HashSHA256"

// Encode creates an HMAC-SHA256 signature for the given byte slice using the provided key.
//
// Args:
//
//        bytes []byte: The byte slice to sign.
//        key string: The key to use for signing.
//
// Returns:
//
//        string: The base64-encoded HMAC-SHA256 signature.
func Encode(bytes []byte, key string) string <span class="cov0" title="0">{
        h := hmac.New(sha256.New, []byte(key))
        h.Write(bytes)
        return base64.StdEncoding.EncodeToString(h.Sum(nil))
}</span>

// Writer wraps an http.ResponseWriter to add HMAC-SHA256 signatures to responses.
type Writer struct {
        http.ResponseWriter
        Key   string // The key used for signing.
        RHash string // The previously set response hash.
}

// Write adds the HMAC-SHA256 signature to the response headers before writing to the underlying writer.
//
// Args:
//
//        b []byte: The byte slice to write to the response.
//
// Returns:
//
//        int: The number of bytes written.
//        error: Any error encountered while writing.
func (hw Writer) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if hw.RHash != "" &amp;&amp; hw.Key != "" </span><span class="cov0" title="0">{
                hw.Header().Set(Header, Encode(b, hw.Key))
        }</span>
        <span class="cov0" title="0">n, err := hw.ResponseWriter.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("%w", err)
        }</span>
        <span class="cov0" title="0">return n, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package retrying

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "metrics/internal/server/logger"
        "time"

        "github.com/avast/retry-go"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
        "go.uber.org/zap"
)

// addTime is the additional delay added to the initial delay for subsequent retries.
const addTime = 2

// Attempts specifies the maximum number of retry attempts.
const Attempts uint = 3

// DelayType calculates the duration for the next retry attempt.
func DelayType(n uint, _ error, config *retry.Config) time.Duration <span class="cov0" title="0">{
        switch n </span>{
        case 0:<span class="cov0" title="0">
                return 1 * time.Second</span>
        case 1:<span class="cov0" title="0">
                return (1 + addTime) * time.Second</span>
        default:<span class="cov0" title="0">
                return (1 + addTime + addTime) * time.Second</span>
        }
}

// OnRetry logs information about the retry attempt.
func OnRetry(n uint, err error) <span class="cov0" title="0">{
        logger.Log.Error(fmt.Sprintf(`%d %s`, n, err.Error()))
}</span>

// Transaction represents a database transaction interface.
type Transaction interface {
        ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
}

// ExecContext executes a SQL query using the provided transaction and retry logic.
func ExecContext(ctx context.Context, tx Transaction, query string, args ...any) error <span class="cov0" title="0">{
        var originalErr error
        err := retry.Do(
                func() error </span><span class="cov0" title="0">{
                        _, originalErr := tx.ExecContext(
                                ctx,
                                query,
                                args...,
                        )
                        if originalErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w", originalErr)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                retry.RetryIf(func(err error) bool <span class="cov0" title="0">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) &amp;&amp; pgerrcode.IsConnectionException(pgErr.Code) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }),
                retry.Attempts(Attempts),
                retry.DelayType(DelayType),
                retry.OnRetry(OnRetry),
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("retryError", zap.Error(err), zap.Error(originalErr))
                return fmt.Errorf("%w", originalErr)
        }</span>
        <span class="cov0" title="0">return originalErr</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
